<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>Piano Pattern Generator & Vocal Trainer</title>
<script src='https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js'></script>
<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
<style>
  /* --- STYLES --- */
  body { font-family: Arial, sans-serif; padding: 15px; background: linear-gradient(135deg,#6a0dad,#4b0082); color: #fff; }
  label{ display:block; margin:8px 0; font-weight:bold; }
  select,input,button{ margin-top:4px; padding:6px; font-size:14px; border-radius:4px; border:none; }
  input,select{ width:150px; }
  button{ margin-top:12px; background:#00f; color:#fff; cursor:pointer; font-weight:bold; }
  button:hover{ background:#0080ff; }
  h3{ text-align:center; }

  /* Layout Container */
  .main-layout { display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap; }
  #generatorControls { flex: 1.2; min-width: 380px; }

  .note-select { display: inline-flex; gap: 6px; }
  .note-select select { width: auto; }

  /* PIANO KEYBOARD STYLES */
  #keyboard{ display:flex; margin-top:10px; justify-content:flex-start; position:relative; height:180px; }
  
  .key { 
    width:32px; height:160px; margin:1px; border:1px solid #000; border-radius:0 0 5px 5px; 
    position:absolute; background:white; transition: background 0.1s; 
    display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
    padding-bottom: 12px; box-sizing: border-box; color: #000; 
    font-weight: 900; font-size: 11px; user-select: none; text-align: center; line-height: 1.2;
  }

  .key.black { 
    width:22px; height:100px; background:black; position:absolute; top:0; z-index:2; 
    color: #fff; font-size: 10px; padding-bottom: 8px; border-radius: 0 0 3px 3px;
  }

  .active { background:#ff0 !important; color: #000 !important; border-color: #aa0; }
  .match-glow { background: #0ff !important; color: #000 !important; box-shadow: 0 0 20px #0ff; z-index: 10; border-color: #0aa; }

  .vocal-ui-box { border: 1px solid #0ff; padding: 10px; margin-bottom: 15px; background: rgba(0,255,255,0.1); border-radius: 4px; }
  .hidden { display: none; }
  .feedback-list { margin-top: 10px; font-size: 16px; list-style: none; padding: 0; font-weight: bold; }

  #vocalFeedbackArea { margin-top: 30px; max-width: 880px; }

  /* Repositioned Tutorial Style */
  #tutorial { 
    flex: 1; min-width: 320px; padding: 15px; background: rgba(0,0,0,0.2); 
    border-radius: 8px; line-height: 1.5; border: 1px solid rgba(0, 255, 255, 0.3);
    font-size: 14px;
  }
  #tutorial strong { color: #0ff; display: block; margin-bottom: 10px; font-size: 16px; }
  #tutorial div { margin-bottom: 6px; }

  #timelineContainer { margin-top: 25px; position: relative; width: 100%; max-width: 880px; }
  #timeline { width: calc(100% - 140px); vertical-align: middle; }
</style>
</head>
<body>
<h3>Piano Pattern Generator & Vocal Trainer</h3>

<div class="main-layout">
    <div id="generatorControls">
        <label>System Mode: 
          <select id="mainMode" onchange="toggleMode()" style="width: 200px;">
            <option value="gen">Generator / MIDI</option>
            <option value="vocal">Tuner Mode (Mic)</option>
          </select>
        </label>
        
        <div id="vocalSettings" class="hidden">
          <button onclick="initMic()" style="background:#0ff; color:#000;">üé§ Enable Microphone</button>
          <button onclick="repeatCurrentVocal()" style="background:#ff8000; color:#fff; margin-left:10px;">üîÅ Repeat Pattern</button>
          <label style="display:inline-block; margin-left:15px;">Vocal Validation:
            <select id="vocalMethod" style="width:120px;">
              <option value="single">Note by Note</option>
              <option value="pattern" selected>Full Pattern</option>
            </select>
          </label>
        </div>

        <label>Highlighted Root:
          <span class="note-select"><select id='rootNoteName'></select><select id='rootNoteOctave'></select></span>
        </label>
        <label>Scale Type:
          <select id='scaleType'><option value='major'>Major</option><option value='minor'>Natural Minor</option></select>
        </label>
        <label>Pattern (degrees): <input id='pattern' value='5,3,1'></label>
        <label>Lowest Note for Pattern:
          <span class="note-select"><select id='rangeStartName'></select><select id='rangeStartOctave'></select></span>
        </label>
        <label>Highest Note for Pattern:
          <span class="note-select"><select id='rangeEndName'></select><select id='rangeEndOctave'></select></span>
        </label>
        <label>Loop Mode:<select id='loopMode'><option value='bounce'>Loop</option><option value='once'>One Cycle</option></select></label>
        <label>Tempo (ms): <input id='tempo' type='number' value='400'></label>

        <button onclick='playPattern()'>Play</button>
        <button onclick='pausePattern()'>Pause</button>
        <button onclick='stopPattern()'>Stop</button>
    </div>

    <div id="tutorial">
      <strong>How-to Tutorial</strong>
      <div>1) Select Tuner or Generator mode.</div>
      <div>2) Input lowest note you want to be highlighted on the piano.</div>
      <div>3) Select scale type.</div>
      <div>4) Type in a pattern of interval degrees i.e. 5,3,1.</div>
      <div>5) Select the lowest note you want the pattern to hit.</div>
      <div>6) Select the highest note you want the pattern to hit.</div>
      <div>7) Select if you want the notes in the exercise to loop.</div>
      <div>8) If on generator mode, set a tempo.</div>
      <div>9) If on tuner mode, select if you want the pattern to have you match note by note or after the full pattern plays.</div>
      <div>10) If on Tuner mode, enable microphone.</div>
      <div>11) Hit Play.
    </div>
</div>

<div id="timelineContainer">
  <input id="timeline" type="range" min="0" max="0" step="50" value="0">
  <span id="timeLabel">00:00 / 00:00</span>
</div>

<div id="vocalFeedbackArea" class="hidden">
    <div class="vocal-ui-box">
        <span id="vocalStatus" style="font-weight:bold; font-size: 18px;">Mic Offline</span>
        <div id="pitchGuide" style="margin-top:5px; color:#0ff; font-size:24px; font-weight:bold;">--</div>
        <ul id="patternFeedback" class="feedback-list"></ul>
    </div>
</div>

<div id='keyboard'></div>

<script>
// All existing logic (JS) remains the same as previously optimized
const pitchNames=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const octaves=[2,3,4,5,6,7];
const scales={ major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10] };
const flatNames = { "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab", "A#": "Bb" };

function populateDropdown(id, arr, def){
  const s=document.getElementById(id);
  arr.forEach(val=>{ const opt=document.createElement('option'); opt.value=val; opt.text=val; if(val==def) opt.selected=true; s.appendChild(opt); });
}
populateDropdown('rootNoteName', pitchNames, 'C'); populateDropdown('rootNoteOctave', octaves, '4');
populateDropdown('rangeStartName', pitchNames, 'C'); populateDropdown('rangeStartOctave', octaves, '3');
populateDropdown('rangeEndName', pitchNames, 'C'); populateDropdown('rangeEndOctave', octaves, '5');

const piano = new Tone.Sampler({
  urls: { "C1": "C1.mp3", "C4": "C4.mp3", "C7": "C7.mp3", "A1": "A1.mp3", "A4": "A4.mp3" },
  baseUrl: "https://tonejs.github.io/audio/salamander/",
  onload: () => console.log("Piano samples ready!")
}).toDestination();

const keyboardDiv = document.getElementById('keyboard');
const allKeys = [];
let whiteCount = 0;
const whiteKeyWidth = 32;

for(let o=2; o<=7; o++){
  ['C','D','E','F','G','A','B'].forEach(w => {
    const wk = document.createElement('div'); 
    wk.className='key'; wk.dataset.note = w+o; wk.style.left=(whiteCount*whiteKeyWidth)+'px';
    wk.innerHTML = `<span>${w}${o}</span>`;
    keyboardDiv.appendChild(wk); allKeys.push(wk);
    if(['C','D','F','G','A'].includes(w)){
      const bk = document.createElement('div'); 
      const sharpNote = w+'#';
      const flatNote = flatNames[sharpNote];
      bk.className='key black'; bk.dataset.note = sharpNote+o; 
      bk.style.left=(whiteCount*whiteKeyWidth + (whiteKeyWidth * 0.65))+'px';
      bk.innerHTML = `<div>${flatNote}</div><div>${sharpNote}</div><div style="font-size:8px; margin-top:2px;">${o}</div>`;
      keyboardDiv.appendChild(bk); allKeys.push(bk);
    }
    whiteCount++;
  });
}
keyboardDiv.style.width=(whiteCount*whiteKeyWidth)+'px';

let walkTimeouts=[]; let isPaused=false; let scheduledEvents=[]; let totalDurationMs=0;
let playStartSystemTime=0; let playStartOffset=0; let progressInterval=null;
let mic, analyser, vocalTargetMidi=null, vocalSequence=[], currentStepIdx=0, subNoteIdx=0;
let patternChecklist = [];
let lastMatchTime = 0;

function noteToMidi(note){ const p={C:0,'C#':1,D:2,'D#':3,E:4,F:5,'F#':6,G:7,'G#':8,A:9,'A#':10,B:11}; const m=note.match(/^([A-G]#?)(\d)$/); return p[m[1].toUpperCase()]+(parseInt(m[2])+1)*12; }
function midiToNote(midi){ return pitchNames[midi%12]+(Math.floor(midi/12)-1); }

function toggleMode(){ 
  const isVocal = document.getElementById('mainMode').value === 'vocal';
  document.getElementById('vocalSettings').classList.toggle('hidden', !isVocal); 
  document.getElementById('vocalFeedbackArea').classList.toggle('hidden', !isVocal); 
}

async function initMic(){
  await Tone.start(); mic=new Tone.UserMedia(); analyser=new Tone.Analyser("fft", 4096);
  try { await mic.open(); mic.connect(analyser); document.getElementById('vocalStatus').innerText="üé§ Mic Active"; pitchLoop(); } catch(e){ alert("Mic error"); }
}

function pitchLoop(){
  if(!analyser) return;
  const buf=analyser.getValue(); let max=-Infinity, idx=-1;
  for(let i=0; i<buf.length; i++){ if(buf[i]>max){max=buf[i]; idx=i;} }
  const freq=idx*(Tone.context.sampleRate/2/buf.length);
  const now = Date.now();
  const g = document.getElementById('pitchGuide');
  if(freq > 60){
    const midi = 12 * Math.log2(freq / 440) + 69;
    const note = midiToNote(Math.round(midi));
    allKeys.forEach(k => k.classList.remove('match-glow'));
    const key = allKeys.find(k => k.dataset.note === note);
    if(key) key.classList.add('match-glow');
    if(vocalTargetMidi){
      const diff = midi - vocalTargetMidi;
      if(Math.abs(diff) < 0.4){ 
        g.innerText = "‚úì Match"; g.style.color = "#0f0"; lastMatchTime = now;
        if(!this.isValidating) {
           this.isValidating = true;
           if(document.getElementById('vocalMethod').value === 'single') validateSubNoteHit(); else validateFullPatternHit(Math.round(midi));
           setTimeout(() => { this.isValidating = false; }, 400); 
        }
      } else if (now - lastMatchTime > 300) {
        g.innerText = diff > 0 ? "‚Üì Lower" : "‚Üë Higher"; g.style.color = diff > 0 ? "#f44" : "#4af"; 
      }
    }
  } else if (now - lastMatchTime > 300) { g.innerText = "--"; allKeys.forEach(k => k.classList.remove('match-glow')); }
  requestAnimationFrame(pitchLoop);
}

function validateSubNoteHit(){
  vocalTargetMidi=null; subNoteIdx++;
  const currentStep = vocalSequence[currentStepIdx];
  if(subNoteIdx < currentStep.notes.length) setTimeout(playSubNote, 1000);
  else {
    document.getElementById('pitchGuide').innerText = "‚ú® Step Finished!";
    currentStepIdx++; subNoteIdx = 0;
    if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 1500);
  }
}

function validateFullPatternHit(midiMatched){
  let foundIdx = patternChecklist.findIndex(item => item.midi === midiMatched && !item.hit);
  if(foundIdx !== -1) { patternChecklist[foundIdx].hit = true; updatePatternUI(); let nextNote = patternChecklist.find(item => !item.hit); if(nextNote) vocalTargetMidi = nextNote.midi; }
  if(patternChecklist.every(item => item.hit)) { document.getElementById('pitchGuide').innerText = "‚ú® PATTERN MATCHED!"; vocalTargetMidi = null; currentStepIdx++; if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 2000); }
}

function updatePatternUI() {
  const list = document.getElementById('patternFeedback'); list.innerHTML = "";
  patternChecklist.forEach(item => { const li = document.createElement('li'); li.style.color = item.hit ? "#0f0" : "#fff"; li.innerText = (item.hit ? "‚úì " : "‚óã ") + item.note; list.appendChild(li); });
}

function nextVocalStep(){
  const method = document.getElementById('vocalMethod').value;
  const step = vocalSequence[currentStepIdx]; if(!step) return;
  if(method === 'single') { subNoteIdx = 0; playSubNote(); } 
  else {
    document.getElementById('vocalStatus').innerText="Listen...";
    patternChecklist = step.notes.map(n => ({ midi: n.midi, note: n.note, hit: false }));
    updatePatternUI();
    step.notes.forEach((n, i) => { setTimeout(() => { piano.triggerAttackRelease(n.note, "4n"); highlightKey(n.note); }, i * 600); });
    setTimeout(() => { vocalTargetMidi = step.notes[0].midi; document.getElementById('vocalStatus').innerText="Sing Pattern!"; }, step.notes.length * 600);
  }
}

function playSubNote(){
  const step = vocalSequence[currentStepIdx]; const target = step.notes[subNoteIdx]; vocalTargetMidi = target.midi;
  piano.triggerAttackRelease(target.note, "2n"); document.getElementById('vocalStatus').innerText=`Sing: ${target.note}`; highlightKey(target.note);
}

function highlightKey(note) { allKeys.forEach(k=>k.classList.remove('active')); const k=allKeys.find(k=>k.dataset.note===note); if(k) k.classList.add('active'); }

function generateWalk(rs, re, st, dl, lm){
  const sequence=[]; let asc=true; let root=rs; const steps=scales[st];
  while(sequence.length<100){
    const notes=[]; dl.forEach(d=>{ const off=steps[(d.degree-1)%7]+Math.floor((d.degree-1)/7)*12+d.accidental; notes.push({midi:root+off, dashes:d.dashes}); });
    if(notes.some(n=>n.midi>=rs && n.midi<=re)) sequence.push({notes});
    const max=Math.max(...notes.map(n=>n.midi)); const min=Math.min(...notes.map(n=>n.midi));
    if(asc){ if(max>=re){asc=false; root--;} else root++; } else { if(min<=rs){ if(lm==='once') break; asc=true; root++; } else root--; }
  }
  return sequence;
}

async function playPattern(){
  await Tone.start(); stopPattern();
  const rs=noteToMidi(document.getElementById('rangeStartName').value+document.getElementById('rangeStartOctave').value);
  const re=noteToMidi(document.getElementById('rangeEndName').value+document.getElementById('rangeEndOctave').value);
  const patternInput=document.getElementById('pattern').value.split(',').map(s=>{
    let acc=0; if(s.trim()[0]==='b') acc=-1; else if(s.trim()[0]==='#') acc=1;
    return { degree:parseInt(s.replace(/[^\d]/g,'')), accidental:acc, dashes:(s.match(/-/g)||[]).length };
  });
  const walk=generateWalk(rs, re, document.getElementById('scaleType').value, patternInput, document.getElementById('loopMode').value);
  if(document.getElementById('mainMode').value==='vocal'){
    vocalSequence=[]; walk.forEach(w => { vocalSequence.push({ notes: w.notes.map(n => ({ midi: n.midi, note: midiToNote(n.midi) })) }); });
    currentStepIdx=0; nextVocalStep();
  } else {
    let time=0; let tempo=parseInt(document.getElementById('tempo').value)||400; scheduledEvents=[];
    walk.forEach((step, i)=>{
        step.notes.forEach(vn=>{ const n=midiToNote(vn.midi); let ms=vn.dashes>0?(1400*vn.dashes):tempo; scheduledEvents.push({type:'note', time, note:n, dur:ms/1000+"s"}); time+=ms+(vn.dashes>0?500:0); });
        if(walk[i+1]){ const s=[...walk[i+1].notes].sort((a,b)=>a.midi-b.midi); const v=[s[0].midi, s[Math.floor(s.length/2)].midi, s[s.length-1].midi].map(m=>midiToNote(m)); scheduledEvents.push({type:'vamp', time:time+800, notes:v, dur:0.7}); time+=2300; }
    });
    totalDurationMs=time; document.getElementById('timeline').max=time; scheduleFromOffset(0);
  }
}

function scheduleFromOffset(offset){
  playStartSystemTime=Date.now(); playStartOffset=offset;
  scheduledEvents.forEach(ev=>{
    if(ev.time < offset) return;
    walkTimeouts.push(setTimeout(()=>{
      if(ev.type==='note'){ piano.triggerAttackRelease(ev.note, ev.dur); highlightKey(ev.note); setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 300); } 
      else { piano.triggerAttackRelease(ev.notes, ev.dur); ev.notes.forEach(n=>{ const k=allKeys.find(k=>k.dataset.note===n); if(k) k.classList.add('active'); }); setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 600); }
    }, ev.time-offset));
  });
  progressInterval=setInterval(()=>{
    const cur=Date.now()-playStartSystemTime+playStartOffset; document.getElementById('timeline').value=cur; document.getElementById('timeLabel').innerText=Math.floor(cur/1000)+"s / "+Math.floor(totalDurationMs/1000)+"s"; if(cur>=totalDurationMs) stopPattern();
  },100);
}

function stopPattern(){ walkTimeouts.forEach(clearTimeout); walkTimeouts=[]; clearInterval(progressInterval); allKeys.forEach(k=>k.classList.remove('active')); vocalTargetMidi=null; document.getElementById('patternFeedback').innerHTML=""; }
function pausePattern(){ walkTimeouts.forEach(clearTimeout); clearInterval(progressInterval); }
</script>
</body>
</html>

