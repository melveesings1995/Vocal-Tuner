<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>Piano Pattern Generator & Vocal Trainer</title>
<script src='https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js'></script>
<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
<style>
  /* --- STYLES --- */
  body { font-family: Arial, sans-serif; padding: 15px; background: linear-gradient(135deg,#6a0dad,#4b0082); color: #fff; }
  label{ display:block; margin:8px 0; font-weight:bold; }
  select,input,button{ margin-top:4px; padding:6px; font-size:14px; border-radius:4px; border:none; }
  input,select{ width:150px; }
  button{ margin-top:12px; background:#00f; color:#fff; cursor:pointer; font-weight:bold; }
  button:hover{ background:#0080ff; }
  h3{ text-align:center; }

  .note-select { display: inline-flex; gap: 6px; }
  .note-select select { width: auto; }

  /* PIANO KEYBOARD STYLES */
  #keyboard{ display:flex; margin-top:15px; justify-content:flex-start; position:relative; height:180px; }
  
  .key { 
    width:32px; 
    height:160px; 
    margin:1px; 
    border:1px solid #000; 
    border-radius:0 0 5px 5px; 
    position:absolute; 
    background:white; 
    transition: background 0.1s; 
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    padding-bottom: 12px;
    box-sizing: border-box;
    color: #000; 
    font-weight: 900; /* Extra bold for legibility */
    font-size: 11px;
    user-select: none;
    text-align: center;
    line-height: 1.2;
  }

  .key.black { 
    width:22px; 
    height:100px; 
    background:black; 
    position:absolute; 
    top:0; 
    z-index:2; 
    color: #fff; 
    font-size: 10px;
    padding-bottom: 8px;
    border-radius: 0 0 3px 3px;
  }

  /* State Colors */
  .active { background:#ff0 !important; color: #000 !important; border-color: #aa0; }
  .match-glow { background: #0ff !important; color: #000 !important; box-shadow: 0 0 20px #0ff; z-index: 10; border-color: #0aa; }

  /* Vocal Feedback */
  .vocal-ui-box { border: 1px solid #0ff; padding: 10px; margin-bottom: 15px; background: rgba(0,255,255,0.1); border-radius: 4px; }
  .hidden { display: none; }
  .feedback-list { margin-top: 10px; font-size: 14px; list-style: none; padding: 0; }
  .feedback-item { margin-bottom: 4px; border-left: 3px solid transparent; padding-left: 8px; }

  #timelineContainer { margin-top: 35px; position: relative; width: 100%; max-width: 880px; }
  #timeline { width: calc(100% - 140px); vertical-align: middle; }
  #timeLabel { display:inline-block; width:120px; text-align:left; margin-left:8px; font-weight:normal; }
  
  .inline-controls { display:flex; gap:20px; align-items:flex-end; margin-top:15px; border-top: 1px solid rgba(255,255,255,0.2); padding-top:15px; }
  #midiFileInput { width:250px; background:#fff; color:#000; }

  #tutorial { margin-top: 25px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; max-width: 880px; line-height: 1.6; }
</style>
</head>
<body>
<h3>Piano Pattern Generator & Vocal Trainer</h3>

<div class="vocal-ui-box">
  <label>System Mode: 
    <select id="mainMode" onchange="toggleMode()" style="width: 200px;">
      <option value="gen">Generator / MIDI</option>
      <option value="vocal">Vocal Trainer (Mic)</option>
    </select>
  </label>
  <div id="vocalControls" class="hidden">
    <button onclick="initMic()" style="background:#0ff; color:#000;">üé§ Enable Microphone</button>
    <button onclick="repeatCurrentVocal()" style="background:#ff8000; color:#fff; margin-left:10px;">üîÅ Repeat Pattern/Note</button>
    
    <label style="display:inline-block; margin-left:15px;">Vocal Validation:
      <select id="vocalMethod" style="width:120px;">
        <option value="single">One Note at a Time</option>
        <option value="pattern" selected>Full Pattern Back-to-Back</option>
      </select>
    </label>
    <span id="vocalStatus" style="margin-left:15px; font-weight:bold;">Mic Offline</span>
    <div id="pitchGuide" style="margin-top:5px; color:#0ff; font-size:18px;">--</div>
    <ul id="patternFeedback" class="feedback-list"></ul>
  </div>
</div>

<div id="generatorControls">
    <label>Lowest Note Highlighted:
      <span class="note-select"><select id='rootNoteName'></select><select id='rootNoteOctave'></select></span>
    </label>
    <label>Scale Type:
      <select id='scaleType'><option value='major'>Major</option><option value='minor'>Natural Minor</option></select>
    </label>
    <label>Pattern (degrees): <input id='pattern' value='1,3,5'></label>
    <label>Lowest Note:
      <span class="note-select"><select id='rangeStartName'></select><select id='rangeStartOctave'></select></span>
    </label>
    <label>Highest Note:
      <span class="note-select"><select id='rangeEndName'></select><select id='rangeEndOctave'></select></span>
    </label>
    <label>Loop Mode:<select id='loopMode'><option value='bounce'>Bounce Forever</option><option value='once'>One Loop</option></select></label>
    <label>Tempo (ms): <input id='tempo' type='number' value='400'></label>

    <div class="inline-controls">
      <div><label>Upload MIDI:</label><input id="midiFileInput" type="file" accept=".mid,.midi" /></div>
      <button id="clearMidiBtn" style="background:#8000ff;">Clear MIDI</button>
      <div><label>MIDI BPM: <span id="tempoValue">120</span></label><input id="tempoSlider" type="range" min="40" max="240" value="120" /></div>
    </div>
</div>

<button onclick='playPattern()'>Play</button>
<button onclick='pausePattern()'>Pause</button>
<button onclick='resumePattern()'>Resume</button>
<button onclick='stopPattern()'>Stop</button>

<div id="timelineContainer">
  <input id="timeline" type="range" min="0" max="0" step="50" value="0">
  <span id="timeLabel">00:00 / 00:00</span>
</div>

<div id='keyboard'></div>

<div id="tutorial">
  <strong>How-to Tutorial:</strong>
  <p>1) Select Generator or Trainer mode</p>
  <p>2) Input lowest note you want to be highlighted on the piano</p>
  <p>3) Select scale type.</p>
  <p>4) Type in a pattern of interval degrees i.e. 5,3,1</p>
  <p>5) Select the lowest note you want the exercise to hit.</p>
  <p>6) Select the highest note you want the exercise to hit.</p>
  <p>7) Select if you want the notes in the exercise to loop</p>
  <p>8) If on generator mode, set a tempo.</p>
  <p>10) If on trainer mode, select if you want the pattern to have you match note by note or after the full pattern plays.</p>
  <p>11) If on trainer mode, enable microphone.</p>
  <p>12) Hit play.</p>
</div>

<script>
const pitchNames=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const octaves=[2,3,4,5,6,7];
const scales={ major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10] };

// Map for enharmonic (flat) names
const flatNames = { "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab", "A#": "Bb" };

function populateDropdown(id, arr, def){
  const s=document.getElementById(id);
  arr.forEach(val=>{ const opt=document.createElement('option'); opt.value=val; opt.text=val; if(val==def) opt.selected=true; s.appendChild(opt); });
}
populateDropdown('rootNoteName', pitchNames, 'C'); populateDropdown('rootNoteOctave', octaves, '4');
populateDropdown('rangeStartName', pitchNames, 'C'); populateDropdown('rangeStartOctave', octaves, '3');
populateDropdown('rangeEndName', pitchNames, 'C'); populateDropdown('rangeEndOctave', octaves, '5');

const piano = new Tone.Sampler({
  urls: { "C1": "C1.mp3", "C4": "C4.mp3", "C7": "C7.mp3", "A1": "A1.mp3", "A4": "A4.mp3" },
  baseUrl: "https://tonejs.github.io/audio/salamander/",
  onload: () => console.log("Piano samples ready!")
}).toDestination();

// KEYBOARD GENERATION
const keyboardDiv = document.getElementById('keyboard');
const allKeys = [];
let whiteCount = 0;
const whiteKeyWidth = 32;

for(let o=2; o<=7; o++){
  ['C','D','E','F','G','A','B'].forEach(w => {
    // White Key
    const wk = document.createElement('div'); 
    wk.className='key'; 
    wk.dataset.note = w+o; 
    wk.style.left=(whiteCount*whiteKeyWidth)+'px';
    wk.innerHTML = `<span>${w}${o}</span>`;
    keyboardDiv.appendChild(wk); allKeys.push(wk);
    
    // Black Key
    if(['C','D','F','G','A'].includes(w)){
      const bk = document.createElement('div'); 
      const sharpNote = w+'#';
      const flatNote = flatNames[sharpNote];
      bk.className='key black'; 
      bk.dataset.note = sharpNote+o; 
      bk.style.left=(whiteCount*whiteKeyWidth + (whiteKeyWidth * 0.65))+'px';
      // Added Flat over Sharp stacked
      bk.innerHTML = `<div>${flatNote}</div><div>${sharpNote}</div><div style="font-size:8px; margin-top:2px;">${o}</div>`;
      keyboardDiv.appendChild(bk); allKeys.push(bk);
    }
    whiteCount++;
  });
}
keyboardDiv.style.width=(whiteCount*whiteKeyWidth)+'px';

/* --- LOGIC REMAINS SAME AS PREVIOUS --- */
let walkTimeouts=[]; let isPaused=false; let scheduledEvents=[]; let totalDurationMs=0;
let playStartSystemTime=0; let playStartOffset=0; let progressInterval=null;
let mic, analyser, vocalTargetMidi=null, vocalSequence=[], currentStepIdx=0, subNoteIdx=0;
let patternChecklist = [];

function noteToMidi(note){ const p={C:0,'C#':1,D:2,'D#':3,E:4,F:5,'F#':6,G:7,'G#':8,A:9,'A#':10,B:11}; const m=note.match(/^([A-G]#?)(\d)$/); return p[m[1].toUpperCase()]+(parseInt(m[2])+1)*12; }
function midiToNote(midi){ return pitchNames[midi%12]+(Math.floor(midi/12)-1); }
function toggleMode(){ document.getElementById('vocalControls').classList.toggle('hidden', document.getElementById('mainMode').value !== 'vocal'); }

async function initMic(){
  await Tone.start(); mic=new Tone.UserMedia(); analyser=new Tone.Analyser("fft", 4096);
  try { await mic.open(); mic.connect(analyser); document.getElementById('vocalStatus').innerText="üé§ Active"; pitchLoop(); } catch(e){ alert("Mic error"); }
}

function pitchLoop(){
  if(!analyser) return;
  const buf=analyser.getValue(); let max=-Infinity, idx=-1;
  for(let i=0; i<buf.length; i++){ if(buf[i]>max){max=buf[i]; idx=i;} }
  const freq=idx*(Tone.context.sampleRate/2/buf.length);
  if(freq>60){
    const midi=12*Math.log2(freq/440)+69; const note=midiToNote(Math.round(midi));
    allKeys.forEach(k=>k.classList.remove('match-glow'));
    const key=allKeys.find(k=>k.dataset.note===note); if(key) key.classList.add('match-glow');
    if(vocalTargetMidi){
      const method = document.getElementById('vocalMethod').value;
      const diff=midi-vocalTargetMidi; const g=document.getElementById('pitchGuide');
      if(Math.abs(diff)<0.4){ 
        g.innerText="‚úì Match"; g.style.color="#0f0"; 
        if(method === 'single') validateSubNoteHit(); else validateFullPatternHit(Math.round(midi));
      } else { 
        g.innerText=diff>0?"‚Üì Lower":"‚Üë Higher"; g.style.color=diff>0?"#f44":"#4af"; 
      }
    }
  }
  requestAnimationFrame(pitchLoop);
}

function validateSubNoteHit(){
  vocalTargetMidi=null; subNoteIdx++;
  const currentStep = vocalSequence[currentStepIdx];
  if(subNoteIdx < currentStep.notes.length) {
    setTimeout(playSubNote, 1000);
  } else {
    document.getElementById('pitchGuide').innerText = "‚ú® Step Finished!";
    currentStepIdx++; subNoteIdx = 0;
    if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 1500);
  }
}

function validateFullPatternHit(midiMatched){
  let foundIdx = patternChecklist.findIndex(item => item.midi === midiMatched && !item.hit);
  if(foundIdx !== -1) {
    patternChecklist[foundIdx].hit = true;
    updatePatternUI();
    let nextNote = patternChecklist.find(item => !item.hit);
    if(nextNote) vocalTargetMidi = nextNote.midi;
  }
  if(patternChecklist.every(item => item.hit)) {
    document.getElementById('pitchGuide').innerText = "‚ú® PATTERN MATCHED!";
    vocalTargetMidi = null; currentStepIdx++;
    if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 2000);
  }
}

function updatePatternUI() {
  const list = document.getElementById('patternFeedback'); list.innerHTML = "";
  patternChecklist.forEach(item => {
    const li = document.createElement('li'); li.className = "feedback-item";
    li.style.color = item.hit ? "#0f0" : "#fff";
    li.innerText = (item.hit ? "‚úì " : "‚óã ") + item.note;
    list.appendChild(li);
  });
}

function nextVocalStep(){
  const method = document.getElementById('vocalMethod').value;
  const step = vocalSequence[currentStepIdx]; 
  if(!step) return;
  if(method === 'single') {
    subNoteIdx = 0; playSubNote();
  } else {
    document.getElementById('vocalStatus').innerText="Listen to Pattern...";
    patternChecklist = step.notes.map(n => ({ midi: n.midi, note: n.note, hit: false }));
    updatePatternUI();
    step.notes.forEach((n, i) => {
      setTimeout(() => {
        piano.triggerAttackRelease(n.note, "4n");
        highlightKey(n.note);
      }, i * 600);
    });
    setTimeout(() => {
      vocalTargetMidi = step.notes[0].midi;
      document.getElementById('vocalStatus').innerText="Match all notes!";
    }, step.notes.length * 600);
  }
}

function playSubNote(){
  const step = vocalSequence[currentStepIdx];
  const target = step.notes[subNoteIdx];
  vocalTargetMidi = target.midi;
  piano.triggerAttackRelease(target.note, "2n");
  document.getElementById('vocalStatus').innerText=`Sing: ${target.note} (Note ${subNoteIdx+1})`;
  highlightKey(target.note);
}

function highlightKey(note) {
  allKeys.forEach(k=>k.classList.remove('active'));
  const k=allKeys.find(k=>k.dataset.note===note); if(k) k.classList.add('active');
}

function repeatCurrentVocal() { if(!vocalSequence[currentStepIdx]) return; nextVocalStep(); }

function generateWalk(rs, re, st, dl, lm){
  const sequence=[]; let asc=true; let root=rs; const steps=scales[st];
  while(sequence.length<100){
    const notes=[]; dl.forEach(d=>{ const off=steps[(d.degree-1)%7]+Math.floor((d.degree-1)/7)*12+d.accidental; notes.push({midi:root+off, dashes:d.dashes}); });
    if(notes.some(n=>n.midi>=rs && n.midi<=re)) sequence.push({notes});
    const max=Math.max(...notes.map(n=>n.midi)); const min=Math.min(...notes.map(n=>n.midi));
    if(asc){ if(max>=re){asc=false; root--;} else root++; }
    else { if(min<=rs){ if(lm==='once') break; asc=true; root++; } else root--; }
  }
  return sequence;
}

async function playPattern(){
  await Tone.start(); stopPattern();
  const rs=noteToMidi(document.getElementById('rangeStartName').value+document.getElementById('rangeStartOctave').value);
  const re=noteToMidi(document.getElementById('rangeEndName').value+document.getElementById('rangeEndOctave').value);
  const patternInput=document.getElementById('pattern').value.split(',').map(s=>{
    let acc=0; if(s.trim()[0]==='b') acc=-1; else if(s.trim()[0]==='#') acc=1;
    return { degree:parseInt(s.replace(/[^\d]/g,'')), accidental:acc, dashes:(s.match(/-/g)||[]).length };
  });
  const walk=generateWalk(rs, re, document.getElementById('scaleType').value, patternInput, document.getElementById('loopMode').value);
  if(document.getElementById('mainMode').value==='vocal'){
    vocalSequence=[]; 
    walk.forEach(w => {
      const stepNotes = w.notes.map(n => ({ midi: n.midi, note: midiToNote(n.midi) }));
      vocalSequence.push({ notes: stepNotes });
    });
    currentStepIdx=0; nextVocalStep();
  } else {
    let time=0; let tempo=parseInt(document.getElementById('tempo').value)||400; scheduledEvents=[];
    walk.forEach((step, i)=>{
        step.notes.forEach(vn=>{
            const n=midiToNote(vn.midi); let ms=vn.dashes>0?(1400*vn.dashes):tempo;
            scheduledEvents.push({type:'note', time, note:n, dur:ms/1000+"s"}); time+=ms+(vn.dashes>0?500:0);
        });
        if(walk[i+1]){
            const s=[...walk[i+1].notes].sort((a,b)=>a.midi-b.midi);
            const v=[s[0].midi, s[Math.floor(s.length/2)].midi, s[s.length-1].midi].map(m=>midiToNote(m));
            scheduledEvents.push({type:'vamp', time:time+800, notes:v, dur:0.7}); time+=2300;
        }
    });
    totalDurationMs=time; document.getElementById('timeline').max=time; scheduleFromOffset(0);
  }
}

function scheduleFromOffset(offset){
  playStartSystemTime=Date.now(); playStartOffset=offset;
  scheduledEvents.forEach(ev=>{
    if(ev.time < offset) return;
    walkTimeouts.push(setTimeout(()=>{
      if(ev.type==='note'){
        piano.triggerAttackRelease(ev.note, ev.dur);
        highlightKey(ev.note); setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 300);
      } else {
        piano.triggerAttackRelease(ev.notes, ev.dur);
        ev.notes.forEach(n=>{ const k=allKeys.find(k=>k.dataset.note===n); if(k) k.classList.add('active'); });
        setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 600);
      }
    }, ev.time-offset));
  });
  progressInterval=setInterval(()=>{
    const cur=Date.now()-playStartSystemTime+playStartOffset;
    document.getElementById('timeline').value=cur;
    document.getElementById('timeLabel').innerText=Math.floor(cur/1000)+"s / "+Math.floor(totalDurationMs/1000)+"s";
    if(cur>=totalDurationMs) stopPattern();
  },100);
}

function stopPattern(){ walkTimeouts.forEach(clearTimeout); walkTimeouts=[]; clearInterval(progressInterval); allKeys.forEach(k=>k.classList.remove('active')); vocalTargetMidi=null; document.getElementById('patternFeedback').innerHTML=""; }
function pausePattern(){ isPaused=true; walkTimeouts.forEach(clearTimeout); clearInterval(progressInterval); }
function resumePattern(){ isPaused=false; scheduleFromOffset(parseInt(document.getElementById('timeline').value)); }
</script>
</body>
</html>
