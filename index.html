<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<title>Piano Pattern Generator & Vocal Trainer</title>
<script src='https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js'></script>
<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
<style>
  /* --- STYLES --- */
  body { font-family: Arial, sans-serif; padding: 15px; background: linear-gradient(135deg,#6a0dad,#4b0082); color: #fff; }
  label{ display:block; margin:8px 0; font-weight:bold; }
  select,input,button{ margin-top:4px; padding:6px; font-size:14px; border-radius:4px; border:none; }
  input,select{ width:150px; }
  button{ margin-top:12px; background:#00f; color:#fff; cursor:pointer; font-weight:bold; }
  button:hover{ background:#0080ff; }
  h3{ text-align:center; }

  .note-select { display: inline-flex; gap: 6px; }
  .note-select select { width: auto; }

  /* PIANO KEYBOARD STYLES */
  #keyboard{ display:flex; margin-top:10px; justify-content:flex-start; position:relative; height:180px; }
  
  .key { 
    width:32px; height:160px; margin:1px; border:1px solid #000; border-radius:0 0 5px 5px; 
    position:absolute; background:white; transition: background 0.1s; 
    display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
    padding-bottom: 12px; box-sizing: border-box; color: #000; 
    font-weight: 900; font-size: 11px; user-select: none; text-align: center; line-height: 1.2;
  }

  .key.black { 
    width:22px; height:100px; background:black; position:absolute; top:0; z-index:2; 
    color: #fff; font-size: 10px; padding-bottom: 8px; border-radius: 0 0 3px 3px;
  }

  .active { background:#ff0 !important; color: #000 !important; border-color: #aa0; }
  .match-glow { background: #0ff !important; color: #000 !important; box-shadow: 0 0 20px #0ff; z-index: 10; border-color: #0aa; }

  .vocal-ui-box { border: 1px solid #0ff; padding: 10px; margin-bottom: 15px; background: rgba(0,255,255,0.1); border-radius: 4px; }
  .hidden { display: none; }
  .feedback-list { margin-top: 10px; font-size: 16px; list-style: none; padding: 0; font-weight: bold; }
  .feedback-item { margin-bottom: 4px; border-left: 3px solid transparent; padding-left: 8px; }

  #vocalFeedbackArea { margin-top: 30px; max-width: 880px; }

  #timelineContainer { margin-top: 35px; position: relative; width: 100%; max-width: 880px; }
  #timeline { width: calc(100% - 140px); vertical-align: middle; }
  #timeLabel { display:inline-block; width:120px; text-align:left; margin-left:8px; font-weight:normal; }
  
  .inline-controls { display:flex; gap:20px; align-items:flex-end; margin-top:15px; border-top: 1px solid rgba(255,255,255,0.2); padding-top:15px; }
  #midiFileInput { width:250px; background:#fff; color:#000; }
</style>
</head>
<body>
<h3>Piano Pattern Generator & Vocal Trainer</h3>

<div id="generatorControls">
    <label>System Mode: 
      <select id="mainMode" onchange="toggleMode()" style="width: 200px;">
        <option value="gen">Generator / MIDI</option>
        <option value="vocal">Vocal Trainer (Mic)</option>
      </select>
    </label>
    
    <div id="vocalSettings" class="hidden">
      <button onclick="initMic()" style="background:#0ff; color:#000;">üé§ Enable Microphone</button>
      <button onclick="repeatCurrentVocal()" style="background:#ff8000; color:#fff; margin-left:10px;">üîÅ Repeat Pattern</button>
      <label style="display:inline-block; margin-left:15px;">Vocal Validation:
        <select id="vocalMethod" style="width:120px;">
          <option value="single">One Note at a Time</option>
          <option value="pattern" selected>Full Pattern Back-to-Back</option>
        </select>
      </label>
    </div>

    <label>Lowest Note Highlighted:
      <span class="note-select"><select id='rootNoteName'></select><select id='rootNoteOctave'></select></span>
    </label>
    <label>Scale Type:
      <select id='scaleType'><option value='major'>Major</option><option value='minor'>Natural Minor</option></select>
    </label>
    <label>Pattern (degrees): <input id='pattern' value='1,3,5'></label>
    <label>Lowest Note:
      <span class="note-select"><select id='rangeStartName'></select><select id='rangeStartOctave'></select></span>
    </label>
    <label>Highest Note:
      <span class="note-select"><select id='rangeEndName'></select><select id='rangeEndOctave'></select></span>
    </label>
    <label>Loop Mode:<select id='loopMode'><option value='bounce'>Bounce Forever</option><option value='once'>One Loop</option></select></label>
    <label>Tempo (ms): <input id='tempo' type='number' value='400'></label>

    <div class="inline-controls">
      <div><label>Upload MIDI:</label><input id="midiFileInput" type="file" accept=".mid,.midi" /></div>
      <button id="clearMidiBtn" style="background:#8000ff;">Clear MIDI</button>
      <div><label>MIDI BPM: <span id="tempoValue">120</span></label><input id="tempoSlider" type="range" min="40" max="240" value="120" /></div>
    </div>
</div>

<button onclick='playPattern()'>Play</button>
<button onclick='pausePattern()'>Pause</button>
<button onclick='resumePattern()'>Resume</button>
<button onclick='stopPattern()'>Stop</button>

<div id="timelineContainer">
  <input id="timeline" type="range" min="0" max="0" step="50" value="0">
  <span id="timeLabel">00:00 / 00:00</span>
</div>

<div id="vocalFeedbackArea" class="hidden">
    <div class="vocal-ui-box">
        <span id="vocalStatus" style="font-weight:bold; font-size: 18px;">Mic Offline</span>
        <div id="pitchGuide" style="margin-top:5px; color:#0ff; font-size:24px; font-weight:bold;">--</div>
        <ul id="patternFeedback" class="feedback-list"></ul>
    </div>
</div>

<div id='keyboard'></div>

<script>
const pitchNames=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const octaves=[2,3,4,5,6,7];
const scales={ major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10] };
const flatNames = { "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab", "A#": "Bb" };

function populateDropdown(id, arr, def){
  const s=document.getElementById(id);
  arr.forEach(val=>{ const opt=document.createElement('option'); opt.value=val; opt.text=val; if(val==def) opt.selected=true; s.appendChild(opt); });
}
populateDropdown('rootNoteName', pitchNames, 'C'); populateDropdown('rootNoteOctave', octaves, '4');
populateDropdown('rangeStartName', pitchNames, 'C'); populateDropdown('rangeStartOctave', octaves, '3');
populateDropdown('rangeEndName', pitchNames, 'C'); populateDropdown('rangeEndOctave', octaves, '5');

const piano = new Tone.Sampler({
  urls: { "C1": "C1.mp3", "C4": "C4.mp3", "C7": "C7.mp3", "A1": "A1.mp3", "A4": "A4.mp3" },
  baseUrl: "https://tonejs.github.io/audio/salamander/",
  onload: () => console.log("Piano samples ready!")
}).toDestination();

const keyboardDiv = document.getElementById('keyboard');
const allKeys = [];
let whiteCount = 0;
const whiteKeyWidth = 32;

for(let o=2; o<=7; o++){
  ['C','D','E','F','G','A','B'].forEach(w => {
    const wk = document.createElement('div'); 
    wk.className='key'; 
    wk.dataset.note = w+o; 
    wk.style.left=(whiteCount*whiteKeyWidth)+'px';
    wk.innerHTML = `<span>${w}${o}</span>`;
    keyboardDiv.appendChild(wk); allKeys.push(wk);
    
    if(['C','D','F','G','A'].includes(w)){
      const bk = document.createElement('div'); 
      const sharpNote = w+'#';
      const flatNote = flatNames[sharpNote];
      bk.className='key black'; 
      bk.dataset.note = sharpNote+o; 
      bk.style.left=(whiteCount*whiteKeyWidth + (whiteKeyWidth * 0.65))+'px';
      bk.innerHTML = `<div>${flatNote}</div><div>${sharpNote}</div><div style="font-size:8px; margin-top:2px;">${o}</div>`;
      keyboardDiv.appendChild(bk); allKeys.push(bk);
    }
    whiteCount++;
  });
}
keyboardDiv.style.width=(whiteCount*whiteKeyWidth)+'px';

let walkTimeouts=[]; let isPaused=false; let scheduledEvents=[]; let totalDurationMs=0;
let playStartSystemTime=0; let playStartOffset=0; let progressInterval=null;
let mic, analyser, vocalTargetMidi=null, vocalSequence=[], currentStepIdx=0, subNoteIdx=0;
let patternChecklist = [];
let lastMatchTime = 0; // Tracking time to expire matches

function noteToMidi(note){ const p={C:0,'C#':1,D:2,'D#':3,E:4,F:5,'F#':6,G:7,'G#':8,A:9,'A#':10,B:11}; const m=note.match(/^([A-G]#?)(\d)$/); return p[m[1].toUpperCase()]+(parseInt(m[2])+1)*12; }
function midiToNote(midi){ return pitchNames[midi%12]+(Math.floor(midi/12)-1); }

function toggleMode(){ 
  const isVocal = document.getElementById('mainMode').value === 'vocal';
  document.getElementById('vocalSettings').classList.toggle('hidden', !isVocal); 
  document.getElementById('vocalFeedbackArea').classList.toggle('hidden', !isVocal); 
}

async function initMic(){
  await Tone.start(); mic=new Tone.UserMedia(); analyser=new Tone.Analyser("fft", 4096);
  try { await mic.open(); mic.connect(analyser); document.getElementById('vocalStatus').innerText="üé§ Mic Active"; pitchLoop(); } catch(e){ alert("Mic error"); }
}

function pitchLoop(){
  if(!analyser) return;
  const buf=analyser.getValue(); let max=-Infinity, idx=-1;
  for(let i=0; i<buf.length; i++){ if(buf[i]>max){max=buf[i]; idx=i;} }
  const freq=idx*(Tone.context.sampleRate/2/buf.length);
  
  const now = Date.now();
  const g = document.getElementById('pitchGuide');

  if(freq > 60){
    const midi = 12 * Math.log2(freq / 440) + 69;
    const note = midiToNote(Math.round(midi));
    
    // Always update glow for current mic pitch
    allKeys.forEach(k => k.classList.remove('match-glow'));
    const key = allKeys.find(k => k.dataset.note === note);
    if(key) key.classList.add('match-glow');

    if(vocalTargetMidi){
      const diff = midi - vocalTargetMidi;
      
      if(Math.abs(diff) < 0.4){ 
        g.innerText = "‚úì Match"; g.style.color = "#0f0"; 
        lastMatchTime = now; // Record success time
        
        // Use a flag to prevent multiple triggers in one breath
        if(!this.isValidating) {
           this.isValidating = true;
           if(document.getElementById('vocalMethod').value === 'single') validateSubNoteHit(); else validateFullPatternHit(Math.round(midi));
           setTimeout(() => { this.isValidating = false; }, 400); 
        }
      } else {
        // Only show Higher/Lower if we haven't matched in the last 0.3s
        if (now - lastMatchTime > 300) {
            g.innerText = diff > 0 ? "‚Üì Lower" : "‚Üë Higher";
            g.style.color = diff > 0 ? "#f44" : "#4af"; 
        }
      }
    }
  } else {
    // If silence or mic dropped, clear "Match" text quickly
    if (now - lastMatchTime > 300) {
      g.innerText = "--";
    }
    allKeys.forEach(k => k.classList.remove('match-glow'));
  }
  requestAnimationFrame(pitchLoop);
}

function validateSubNoteHit(){
  vocalTargetMidi=null; subNoteIdx++;
  const currentStep = vocalSequence[currentStepIdx];
  if(subNoteIdx < currentStep.notes.length) {
    setTimeout(playSubNote, 1000);
  } else {
    document.getElementById('pitchGuide').innerText = "‚ú® Step Finished!";
    currentStepIdx++; subNoteIdx = 0;
    if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 1500);
  }
}

function validateFullPatternHit(midiMatched){
  let foundIdx = patternChecklist.findIndex(item => item.midi === midiMatched && !item.hit);
  if(foundIdx !== -1) {
    patternChecklist[foundIdx].hit = true;
    updatePatternUI();
    let nextNote = patternChecklist.find(item => !item.hit);
    if(nextNote) vocalTargetMidi = nextNote.midi;
  }
  if(patternChecklist.every(item => item.hit)) {
    document.getElementById('pitchGuide').innerText = "‚ú® PATTERN MATCHED!";
    vocalTargetMidi = null; currentStepIdx++;
    if(currentStepIdx < vocalSequence.length) setTimeout(nextVocalStep, 2000);
  }
}

function updatePatternUI() {
  const list = document.getElementById('patternFeedback'); list.innerHTML = "";
  patternChecklist.forEach(item => {
    const li = document.createElement('li'); li.className = "feedback-item";
    li.style.color = item.hit ? "#0f0" : "#fff";
    li.innerText = (item.hit ? "‚úì " : "‚óã ") + item.note;
    list.appendChild(li);
  });
}

function nextVocalStep(){
  const method = document.getElementById('vocalMethod').value;
  const step = vocalSequence[currentStepIdx]; 
  if(!step) return;
  if(method === 'single') {
    subNoteIdx = 0; playSubNote();
  } else {
    document.getElementById('vocalStatus').innerText="Listen to Pattern...";
    patternChecklist = step.notes.map(n => ({ midi: n.midi, note: n.note, hit: false }));
    updatePatternUI();
    step.notes.forEach((n, i) => {
      setTimeout(() => {
        piano.triggerAttackRelease(n.note, "4n");
        highlightKey(n.note);
      }, i * 600);
    });
    setTimeout(() => {
      vocalTargetMidi = step.notes[0].midi;
      document.getElementById('vocalStatus').innerText="Match all notes!";
    }, step.notes.length * 600);
  }
}

function playSubNote(){
  const step = vocalSequence[currentStepIdx];
  const target = step.notes[subNoteIdx];
  vocalTargetMidi = target.midi;
  piano.triggerAttackRelease(target.note, "2n");
  document.getElementById('vocalStatus').innerText=`Sing: ${target.note}`;
  highlightKey(target.note);
}

function highlightKey(note) {
  allKeys.forEach(k=>k.classList.remove('active'));
  const k=allKeys.find(k=>k.dataset.note===note); if(k) k.classList.add('active');
}

function repeatCurrentVocal() { if(!vocalSequence[currentStepIdx]) return; nextVocalStep(); }

function generateWalk(rs, re, st, dl, lm){
  const sequence=[]; let asc=true; let root=rs; const steps=scales[st];
  while(sequence.length<100){
    const notes=[]; dl.forEach(d=>{ const off=steps[(d.degree-1)%7]+Math.floor((d.degree-1)/7)*12+d.accidental; notes.push({midi:root+off, dashes:d.dashes}); });
    if(notes.some(n=>n.midi>=rs && n.midi<=re)) sequence.push({notes});
    const max=Math.max(...notes.map(n=>n.midi)); const min=Math.min(...notes.map(n=>n.midi));
    if(asc){ if(max>=re){asc=false; root--;} else root++; }
    else { if(min<=rs){ if(lm==='once') break; asc=true; root++; } else root--; }
  }
  return sequence;
}

async function playPattern(){
  await Tone.start(); stopPattern();
  const rs=noteToMidi(document.getElementById('rangeStartName').value+document.getElementById('rangeStartOctave').value);
  const re=noteToMidi(document.getElementById('rangeEndName').value+document.getElementById('rangeEndOctave').value);
  const patternInput=document.getElementById('pattern').value.split(',').map(s=>{
    let acc=0; if(s.trim()[0]==='b') acc=-1; else if(s.trim()[0]==='#') acc=1;
    return { degree:parseInt(s.replace(/[^\d]/g,'')), accidental:acc, dashes:(s.match(/-/g)||[]).length };
  });
  const walk=generateWalk(rs, re, document.getElementById('scaleType').value, patternInput, document.getElementById('loopMode').value);
  if(document.getElementById('mainMode').value==='vocal'){
    vocalSequence=[]; 
    walk.forEach(w => {
      const stepNotes = w.notes.map(n => ({ midi: n.midi, note: midiToNote(n.midi) }));
      vocalSequence.push({ notes: stepNotes });
    });
    currentStepIdx=0; nextVocalStep();
  } else {
    let time=0; let tempo=parseInt(document.getElementById('tempo').value)||400; scheduledEvents=[];
    walk.forEach((step, i)=>{
        step.notes.forEach(vn=>{
            const n=midiToNote(vn.midi); let ms=vn.dashes>0?(1400*vn.dashes):tempo;
            scheduledEvents.push({type:'note', time, note:n, dur:ms/1000+"s"}); time+=ms+(vn.dashes>0?500:0);
        });
        if(walk[i+1]){
            const s=[...walk[i+1].notes].sort((a,b)=>a.midi-b.midi);
            const v=[s[0].midi, s[Math.floor(s.length/2)].midi, s[s.length-1].midi].map(m=>midiToNote(m));
            scheduledEvents.push({type:'vamp', time:time+800, notes:v, dur:0.7}); time+=2300;
        }
    });
    totalDurationMs=time; document.getElementById('timeline').max=time; scheduleFromOffset(0);
  }
}

function scheduleFromOffset(offset){
  playStartSystemTime=Date.now(); playStartOffset=offset;
  scheduledEvents.forEach(ev=>{
    if(ev.time < offset) return;
    walkTimeouts.push(setTimeout(()=>{
      if(ev.type==='note'){
        piano.triggerAttackRelease(ev.note, ev.dur);
        highlightKey(ev.note); setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 300);
      } else {
        piano.triggerAttackRelease(ev.notes, ev.dur);
        ev.notes.forEach(n=>{ const k=allKeys.find(k=>k.dataset.note===n); if(k) k.classList.add('active'); });
        setTimeout(()=>allKeys.forEach(k=>k.classList.remove('active')), 600);
      }
    }, ev.time-offset));
  });
  progressInterval=setInterval(()=>{
    const cur=Date.now()-playStartSystemTime+playStartOffset;
    document.getElementById('timeline').value=cur;
    document.getElementById('timeLabel').innerText=Math.floor(cur/1000)+"s / "+Math.floor(totalDurationMs/1000)+"s";
    if(cur>=totalDurationMs) stopPattern();
  },100);
}

function stopPattern(){ walkTimeouts.forEach(clearTimeout); walkTimeouts=[]; clearInterval(progressInterval); allKeys.forEach(k=>k.classList.remove('active')); vocalTargetMidi=null; document.getElementById('patternFeedback').innerHTML=""; }
function pausePattern(){ isPaused=true; walkTimeouts.forEach(clearTimeout); clearInterval(progressInterval); }
function resumePattern(){ isPaused=false; scheduleFromOffset(parseInt(document.getElementById('timeline').value)); }
</script>
</body>
</html>
